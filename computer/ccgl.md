---

title: "操作系统基础-存储管理"
date: 2022-05-12T13:26:11+08:00
draft: false
share: true
author: "Damon"
tags: ["OS", "操作系统"]
categories: ["OS"]
series: ["操作系统"]
image: "/images/os/os.png"

---

# 存储管理
## 1.存储和CPU之间的关系

缓存据有容量小、速度高的特点，而内存相比之下则容量大而速度低。

如下图所示，由于**CPU**跟**内存**之间的速度悬殊，通常在**CPU**跟**内存**之间增加**高速缓存**来提高性能。![](/images/os/CPU-缓存-内存之间的关系.jpg)

因为缓存的容量较小，必然会有内存内容的换进和换出。这就会遵循局部性原理，即**时间局部性**、**空间局部性**

* 时间局部性：某段时间内会重复使用的内容不换出
* 空间局部性：与使用中内容空间联系紧密的不换出

**如何计算Cache的平均访问时间？**

假设：cache的命中率为98%，命中的访问速度为2ns，不命中的访问速度为5ns，则cache的平均访问时间 = 98% * 2 + 2% * 5ns

CPU如何通过缓存访问主存，请看下图：![](/images/os/Cache命中.png)

其中**地址映射变换**解决了主存和Cache块号不一致，因为有可能主存与Cache采用不同的分区策略，同时也增加了Cache的灵活性，可记录主存所有块号的任何为内容。

Cache的映射方式主要有以下几种：

1. **直接映射**：直接映射主存的页到Cache页，不灵活，块(页)冲突率较高；
2. **全相连映像**：主存中的页可以映射到任何Cache中的页，灵活性高，但无法从主存块号中直接获取Cache的块号，需要增加额外映射；
3. **组相连映像**：主存分区、分组，组内使用直接映射，组间使用全相连映像。

***使用：距离CPU较近的可使用直接或组相连映像，距离较远的可使用全相连映射***

**cache与主存的一致性**

1. **写回策略**：CPU对cache写命中时，只修改cache的内容不立即写入主存，只有当此行被换出时才写入主存。
2. **写直达策略**：又称写全或写透策略，cache写命中时，同时修改主存
3. **标记策略**：cache换进时有效标记为1，CPU对cache写命中时，只写入主存并将cache标志位置0；当要从cache读取数据，发现cache标志位为0则直接从主存读取

**cache的替换算法**

1. **随机算法**：当cache满时，随机选择一块替换掉
2. **先进先出（FIFO）**：按进入cache的先后顺序，先进的优先被替换
3. **近期最少使用（LRU）**：优先替换近期最少使用的块
4. **最不经常使用（LFU）**：优先替换最不经常使用的块

## 2.地址重定位

> 是将程序中的虚拟地址(逻辑地址)变换成内存的真实地址(物理地址)的过程

* 逻辑地址：也称为相对地址，是内部和编程使用的、并不唯一
* 物理地址：也称为绝对地址，是加载到内存地址寄存器的地址，内存单元的真正地址

地址重定位分为：**静态重定位** 和 **动态重定位**

* 静态重定位：<span style="color:blue">绝对地址 = 相对地址 + 程序存放的内存起始地址</span>
* 动态重定位：<span style="color:blue">绝对地址 = 重定位寄存器的值（BR）+ 逻辑地址寄存器的值（VR）</span>

静态重定位和动态重定位的优缺点：

* 静态重定位需要在程序运行前就确定程序的位置（地址的映射关系）且不能移动，程序本身也需要占用连续的内存空间；

* 动态重定位可以再程序需要执行是根据BR和VR的记录去调度，占用的内存空间可动态变化，相对比较灵活，但增加了寄存器的开销



## 3.存储管理的分类

> 存储管理的主要目的是解决多个用户使用主存的问题

常见的存储管理方式有以下几种：

1. **分区存储管理**：

   把主存划分为若干区域，每个区域值分配给一个用户作业使用并限定只能在自己的区域中运行；基于分区方式的不同可划分为：**固定分区**、**可变分区**、**可重定位分区**
   使用分区表、标定每个区的区号、大小、起始地址和是否分配标志。![](/images/os/固定分区.jpg)

  ***由于分区大小固定，分配后剩余的空间很容易被浪费掉!
   根据程序的大小，使用不同的算法重新分配到各个分区中***
   ![](/images/os/可变分区.jpg)

   ***依然有空间的浪费，但相比固定分区要好很多*** 

   通过移动内存中作业的位置，然后把原来多个分散的空闲小分区拼接成一个大分区。此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。** ![](/images/os/重定位分区.jpg)

   但由于重定位会增加系统开销，必须选择合适的时机进行，通常有一下两种：

   1. 分区回收时执行；
   2. 找不到足够大空间时执行：

2. **分页存储管理**

   > 为了解决分区存储管理中会产生的大量碎片，分页存储的思想被提出了。
   >
   > 计提思路是：<span style="color:red">把主存存储空间划分为大小一定的块（称为物理块、或页框），把要执行的作业也按照同样的尺寸划分，如此作业便可以零散的放于主存的不连续的页框中，但需要增加页表(页号和页框的映射关系)去寻址。</span>

   ![](/images/os/分页存储管理.jpg)

   如上图所示，作业的各个页面与页框的对应，就是通过页表来实现。
   把作业的地址空间划分成若干个大小相等的区域，称这样的每个区为页面或者简称页。

   相应地，也需将主存空间划分为若干个大小相等的物理块，并使块与页的大小相同，这样，在将用户程序装入内存时，刚好一块中放页。

   页的大小通常在 512B～4KB范围。 

   简称页表，其中列出了作业的逻辑地址与其在主存中 的物理地址间的对应关系。

   一个页表中包含若干个表目，表目中的最基本内容是该页对应的物理块号。
   **假设每个页和物理块的大小均为1024B，逻辑地址为2100(十进制)，计算其物理地址？**![](/images/os/页表.jpg)解：

   * 页号：页号 = 逻辑地址 / 页大小，即：2100 / 1024 = 2
   * 物理块偏移量 = 页偏移量 = 逻辑地址 % 页大小，即：2100 % 1024 = 52
   * 物理块地址 =  物理块号(根据页表和所得页号查找) * 页大小 + 物理块偏移量，即：8 * 1024 + 52 = 8244 

3. **分段存储管理**

   > 分段式存储管理的作业空间是以段为单位的，每个段将占据一个连续的存储区域，但各段之间不必连续。
   >
   > 这样，一个作业的各个分段在主存的情况用一个段表来记录，它指出了主存中各个分段的起始地址和长度。
   >
   > 相对于分页存储来说，分段可以根据程序的实际情况，将程序内联系比较紧密的部分划分到一个段内，保护程序内部的逻辑完整性。

   ![](/images/os/分段存储管理.jpg) <span style="color:red">段表由**段号**、**段长**、**段始址**组成。其中段长起到了限长的作用，逻辑地址到物理地址的换算和分页类似</span> 

4. 段页式存储管理

   > 段页式存储管理兼顾了段式在逻辑上的清晰和页式在管理上方便的特点。
   >
   > 每一个装入内存的作业建立一张段表（基于作业），对每一段建立一张页表（系统决定页大小）

   ![](/images/os/段页式存储管理.jpg)

   **逻辑地址到物理地址的计算：**

   * 访问段表获取段表始址
   * 根据段表始址计算段表分页的页号，从而得到页表始址
   * 根据得到的页表地址得到具体的物理

## 4.磁盘存储器

> 磁盘存储器一般由组合臂、主轴、读写头、盘面组成，盘面又分磁道，磁道分有扇区，扇区用来存储数据。所以磁盘存储器的**存储容量 = 磁盘面数 x 每面的磁道数 x 每道扇区 x 每个扇区存储字节数**，硬盘的存取时间 = 寻道时间 + 等待时间 +读/写时间。

为了加深对硬盘存取时间理解，看下面一道例题：

在磁盘上存储数据的排列方式会影响 I/O 服务的总时间。假设每磁道划 分成 10 个物理块，每块存放 1 个逻辑记录。逻辑记录 RI.R2， ...， RI0存放在同一个磁道上， 记录的安排顺序如下表所示;![](/images/os/磁盘存储题-1.jpg)

假定磁盘的旋转速度为 30ms/周，磁头当前处在 R1 的开始处。若系统顺 序处理这些记录，使用单缓冲区，每个记录处理时间为 6ms，则处理这 10 个记录的**最长时间**为 （） ;若对信息**存储进行优化分布**后，处理 10 个 记录的**最少时间**为（）

<span style="color:red">**解**：</span> 

1. ![:inline](/images/os/磁盘存储题-2.png)磁头初始位置如图所示，读取一条指令的时间 = 30ms / 10 = 3ms，处理一条指令耗时6ms，在处理完R1后，磁头位置如图所示(R1处理完)，此时耗时3ms(读) + 6ms(执行) = 9ms；

   如果开始处理R2，磁头需要从当前位置（R1处理完）空转到R2执行开始处，耗时8 x 3ms = 24ms，因此处理完R1并回到R2的开始位置总耗时 24ms + 9ms = 33ms；

   从R1...R9的耗时 = 33ms x 9 = 297ms，R10读取和执行也需要9ms，因此总耗时 = 297ms + 9ms = 306ms

2. ![:inline](/images/os/磁盘存储题-3.png)假设从新排了顺序使得每次处理完磁头所在位置刚好是下一个要执行的指令，由第一问可知，一条指令完整的执行时间为9ms，10条则为90ms